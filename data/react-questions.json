{
  "questions": [
    {
      "id": "react-hooks",
      "type": "text",
      "question": "Explain React Hooks and their advantages over class components.",
      "answer": "React Hooks are functions that allow you to use state and other React features in functional components. Key advantages include:\n- Simpler code organization\n- Reuse of stateful logic\n- Avoiding wrapper hell from render props and HOCs\n- Avoiding confusion with 'this' binding\n\nCommon hooks include useState, useEffect, useContext, and useRef.",
      "difficulty": "intermediate",
      "tags": ["hooks", "functional-components"]
    },
    {
      "id": "virtual-dom",
      "type": "text",
      "question": "What is the Virtual DOM and how does it work?",
      "answer": "The Virtual DOM is a lightweight copy of the actual DOM that React maintains in memory. When state changes occur:\n1. React creates a new Virtual DOM tree\n2. Compares it with the previous Virtual DOM (diffing)\n3. Calculates the minimum number of changes needed\n4. Updates the actual DOM only where necessary\n\nThis process optimizes performance by reducing expensive DOM operations.",
      "difficulty": "beginner",
      "tags": ["fundamentals", "performance"]
    },
    {
      "id": "usememo-vs-usecallback",
      "type": "multiple-choice",
      "question": "What is the main difference between useMemo and useCallback?",
      "options": [
        "useMemo is for memoizing values, useCallback is for memoizing functions",
        "useMemo is for functions, useCallback is for values",
        "They are exactly the same, just different names",
        "useMemo is for class components, useCallback is for functional components"
      ],
      "correctAnswer": 0,
      "explanation": "useMemo memoizes the result of a computation (a value), while useCallback memoizes a function definition. useMemo(fn, deps) is equivalent to useCallback(() => fn(), deps) when fn returns a function.",
      "difficulty": "intermediate",
      "tags": ["hooks", "optimization"]
    },
    {
      "id": "useeffect-cleanup",
      "type": "text",
      "question": "Explain the cleanup function in useEffect and when you should use it.",
      "answer": "The cleanup function in useEffect is used to prevent memory leaks and handle cleanup tasks. It runs before:\n1. The component unmounts\n2. Before re-running the effect due to dependency changes\n\nCommon use cases:\n- Unsubscribing from subscriptions\n- Clearing timers/intervals\n- Removing event listeners\n- Aborting fetch requests\n\nExample:\nuseEffect(() => {\n  const subscription = someAPI.subscribe();\n  return () => subscription.unsubscribe(); // cleanup\n}, []);",
      "difficulty": "intermediate",
      "tags": ["hooks", "useEffect", "cleanup"]
    },
    {
      "id": "react-keys",
      "type": "multiple-choice",
      "question": "Which of these is the correct way to use keys in React lists?",
      "options": [
        "Using the array index as key: <div key={index}>",
        "Using a unique, stable identifier: <div key={item.id}>",
        "Using Math.random() as key: <div key={Math.random()}>",
        "Not using keys at all: <div>"
      ],
      "correctAnswer": 1,
      "explanation": "Using stable, unique identifiers (like item.id) is the best practice for React keys. Array indices can cause issues with reordering, random values cause unnecessary re-renders, and omitting keys entirely breaks React's reconciliation process.",
      "difficulty": "beginner",
      "tags": ["lists", "keys", "best-practices"]
    },
    {
      "id": "react-lifecycle",
      "type": "text",
      "question": "How do React's class lifecycle methods map to Hooks in functional components?",
      "answer": "Common lifecycle method mappings to Hooks:\n\ncomponentDidMount:\nuseEffect(() => { ... }, [])\n\ncomponentDidUpdate:\nuseEffect(() => { ... }, [dep1, dep2])\n\ncomponentWillUnmount:\nuseEffect(() => {\n  return () => { /* cleanup */ }\n}, [])\n\ncomponentDidCatch/getDerivedStateFromError:\nUse Error Boundaries (still needs class components)\n\nshouldComponentUpdate:\nUse React.memo, useMemo, or useCallback",
      "difficulty": "advanced",
      "tags": ["lifecycle", "hooks", "class-components"]
    },
    {
      "id": "state-management",
      "type": "multiple-choice",
      "question": "Which state management solution would be most appropriate for a small React application with minimal global state?",
      "options": [
        "Redux with Redux Toolkit",
        "Context API with useReducer",
        "MobX",
        "Zustand"
      ],
      "correctAnswer": 1,
      "explanation": "For small applications with minimal global state, Context API with useReducer is the most appropriate choice because:\n- It's built into React\n- No additional dependencies needed\n- Simpler learning curve\n- Sufficient for basic global state needs\n- Easier to refactor later if needed",
      "difficulty": "intermediate",
      "tags": ["state-management", "context", "best-practices"]
    },
    {
      "id": "error-boundaries",
      "type": "text",
      "question": "What are Error Boundaries in React and how do you implement them?",
      "answer": "Error Boundaries are React components that catch JavaScript errors anywhere in their child component tree and handle them gracefully. They:\n\n1. Must be class components\n2. Implement either componentDidCatch() or static getDerivedStateFromError()\n\nExample implementation:\nclass ErrorBoundary extends React.Component {\n  state = { hasError: false };\n\n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    logErrorToService(error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <h1>Something went wrong.</h1>;\n    }\n    return this.props.children;\n  }\n}",
      "difficulty": "advanced",
      "tags": ["error-handling", "class-components"]
    }
  ]
}